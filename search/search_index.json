{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cliar \u00b6 Cliar is a Python package to help you create commandline interfaces. It focuses on simplicity and extensibility: Creating a CLI is as simple as subclassing from cliar.Cliar . Extending a CLI is as simple as subclassing from a cliar.Cliar subclass. Cliar's mission is to let you focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in your way, so it provides the means to customize the generated CLI. Installation \u00b6 $ pip install cliar Cliar requires Python 3.6+ and is tested on Windows, Linux, and macOS. There are no dependencies outside Python's standard library. Basic Usage \u00b6 Let's create a commandline calculator that adds two floats: from cliar import Cliar class Calculator ( Cliar ): '''Calculator app.''' def add ( self , x : float , y : float ): '''Add two numbers.''' print ( f 'The sum of { x } and { y } is { x + y } .' ) if __name__ == '__main__' : Calculator () . parse () Save this code to calc.py and run it. Try different inputs: Valid input: $ python calc.py add 12 34 The sum of 12 .0 and 34 .0 is 46 .0. Invalid input: $ python calc.py add foo bar usage: calc.py add [ -h ] x y calc.py add: error: argument x: invalid float value: 'foo' Help: $ python calc.py -h usage: calc.py [ -h ] { add } ... Calculator app. optional arguments: -h, --help show this help message and exit commands: { add } Available commands: add Add two numbers. Help for add command: $ python calc.py add -h usage: calc.py add [ -h ] x y Add two numbers. positional arguments: x y optional arguments: -h, --help show this help message and exit A few things to note: It's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar. add method is converted to add command, its positional params are converted to positional commandline args. There is no explicit conversion to float for x or y or error handling in the add method body. Instead, x and y are just treated as floats. Cliar converts the types using add 's type hints. Invalid input doesn't even reach your code. --help and -h flags are added automatically and the help messages are generated from the docstrings. Setuptools and Poetry \u00b6 To invoke your CLI via an entrypoint, wrap parse call in a function and point to it in your setup.py or pyproject.toml . calc.py : ... def entry_point(): Calculator().parse() setup.py : setup( ... entry_points = { 'console_scripts': ['calc=calc:entry_point'], } ... ) pyproject.toml : ... [ tool . poetry . scripts ] calc = 'calc:entry_point' Read Next \u00b6 Tutorial \u2192 Cliar vs. Click vs. docopt \u2192","title":"Cliar"},{"location":"#cliar","text":"Cliar is a Python package to help you create commandline interfaces. It focuses on simplicity and extensibility: Creating a CLI is as simple as subclassing from cliar.Cliar . Extending a CLI is as simple as subclassing from a cliar.Cliar subclass. Cliar's mission is to let you focus on the business logic instead of building an interface for it. At the same time, Cliar doesn't want to stand in your way, so it provides the means to customize the generated CLI.","title":"Cliar"},{"location":"#installation","text":"$ pip install cliar Cliar requires Python 3.6+ and is tested on Windows, Linux, and macOS. There are no dependencies outside Python's standard library.","title":"Installation"},{"location":"#basic-usage","text":"Let's create a commandline calculator that adds two floats: from cliar import Cliar class Calculator ( Cliar ): '''Calculator app.''' def add ( self , x : float , y : float ): '''Add two numbers.''' print ( f 'The sum of { x } and { y } is { x + y } .' ) if __name__ == '__main__' : Calculator () . parse () Save this code to calc.py and run it. Try different inputs: Valid input: $ python calc.py add 12 34 The sum of 12 .0 and 34 .0 is 46 .0. Invalid input: $ python calc.py add foo bar usage: calc.py add [ -h ] x y calc.py add: error: argument x: invalid float value: 'foo' Help: $ python calc.py -h usage: calc.py [ -h ] { add } ... Calculator app. optional arguments: -h, --help show this help message and exit commands: { add } Available commands: add Add two numbers. Help for add command: $ python calc.py add -h usage: calc.py add [ -h ] x y Add two numbers. positional arguments: x y optional arguments: -h, --help show this help message and exit A few things to note: It's a regular Python class with a regular Python method. You don't need to learn any new syntax to use Cliar. add method is converted to add command, its positional params are converted to positional commandline args. There is no explicit conversion to float for x or y or error handling in the add method body. Instead, x and y are just treated as floats. Cliar converts the types using add 's type hints. Invalid input doesn't even reach your code. --help and -h flags are added automatically and the help messages are generated from the docstrings.","title":"Basic Usage"},{"location":"#setuptools-and-poetry","text":"To invoke your CLI via an entrypoint, wrap parse call in a function and point to it in your setup.py or pyproject.toml . calc.py : ... def entry_point(): Calculator().parse() setup.py : setup( ... entry_points = { 'console_scripts': ['calc=calc:entry_point'], } ... ) pyproject.toml : ... [ tool . poetry . scripts ] calc = 'calc:entry_point'","title":"Setuptools and Poetry"},{"location":"#read-next","text":"Tutorial \u2192 Cliar vs. Click vs. docopt \u2192","title":"Read Next"},{"location":"changelog/","text":"Changelog \u00b6 1.3.5 (October 21, 2021) \u00b6 Switch from Travis to GitHub Actions. 1.3.4 (December 11, 2019) \u00b6 Add support for async handlers (per #13 ). 1.3.3 (November 29, 2019) \u00b6 Fix #11 : multiword optional args of any type other than bool couldn't be used. 1.3.2 (July 23, 2019) \u00b6 Global args are now stored in self.global_args instead of self._root_args . Global args are now available in nested commands. Read more . 1.3.1 (July 22, 2019) [Removed from PyPI] \u00b6 Commands can now access root command args via self._root_args . Read more . 1.3.0 (July 21, 2019) \u00b6 Add support for nested commands. Read more . Fix incorrect mapping from handler params to optional CLI args. 1.2.5 (June 30, 2019) \u00b6 Prepare for postponed annotation evaluation, which will be the default in Python 4.0 (see #2). 1.2.4 (June 27, 2019) \u00b6 Add show_defaults param to set_help util. Read more . 1.2.3 (May 13, 2019) \u00b6 Fix Python 3.7 incompatibility. Add set_sharg_map to override or disable short arg names. 1.2.2 (June 3, 2018) \u00b6 Make _root not an abstract method. 1.2.1 (June 2, 2018) \u00b6 Fix critical bug that disallowed string params. 1.2.0 (June 1, 2018) \u00b6 Boolean handler params are converted into store_true arguments. Before that, params with default value of True were much confusingly converted into store_false arguments. Support List[int] and similar arg types. If the param type is a subclass of typing.Iterable and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets. Do not print help whenever _root command is invoked. Convert the cliar module into a package. Add tests. Switch to Poetry. 1.1.9 \u00b6 Add the ability to set help messages for arguments. Add the ability to set metavars for arguments. 1.1.8 \u00b6 [Breaks backward compatibility] Base CLI class renamed from CLI to Cliar . Fixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores. 1.1.7 \u00b6 Add the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes. 1.1.6 \u00b6 Underscores in handler names are now replaced with dashes when the corresponding command name is generated. 1.1.5 \u00b6 Optional arguments are now prepended with '--', not '-'. Short argument names are now generated from the long ones: name handler arg corresponds to -n and --name commandline args. Python 2 support dropped. Python 3.5+ required. Code refactored, type hints added. 1.1.4 \u00b6 Code improvements for API documentation. 1.1.3 \u00b6 Code cleanup. 1.1.2 \u00b6 Setup: Python version check improved. 1.1.1 \u00b6 Python 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed. If only the _root handler is defined, the commands subparser is not added anymore. Packaging improved, the installation package now includes both Python 2 and 3 sources. 1.1.0 \u00b6 Command descriptions did not preserve line breaks from docstrings. Fixed. 1.0.9 \u00b6 Commands now use the first docstring line as help and the whole docstring as description. 1.0.8 \u00b6 Description and help texts now preserve line breaks from docstrings. 1.0.7 \u00b6 Support of multiple values for a single arg added. 1.0.6 \u00b6 Command-line args are now parsed by explicitly calling the .parse() method. 1.0.5 \u00b6 The ignore decorator added to exclude a method from being converted into a command. 1.0.4 \u00b6 Nested CLI methods would not override parent methods. Fixed. 1.0.3 \u00b6 Python 2 support added. 1.0.2 \u00b6 Docstring added to the add_aliases function. The set_name function is now less hacky. 1.0.1 \u00b6 Alias support added with the \"add_aliases\" decorator. 1.0.0 \u00b6 First version. Changelog started.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#135-october-21-2021","text":"Switch from Travis to GitHub Actions.","title":"1.3.5 (October 21, 2021)"},{"location":"changelog/#134-december-11-2019","text":"Add support for async handlers (per #13 ).","title":"1.3.4 (December 11, 2019)"},{"location":"changelog/#133-november-29-2019","text":"Fix #11 : multiword optional args of any type other than bool couldn't be used.","title":"1.3.3 (November 29, 2019)"},{"location":"changelog/#132-july-23-2019","text":"Global args are now stored in self.global_args instead of self._root_args . Global args are now available in nested commands. Read more .","title":"1.3.2 (July 23, 2019)"},{"location":"changelog/#131-july-22-2019-removed-from-pypi","text":"Commands can now access root command args via self._root_args . Read more .","title":"1.3.1 (July 22, 2019) [Removed from PyPI]"},{"location":"changelog/#130-july-21-2019","text":"Add support for nested commands. Read more . Fix incorrect mapping from handler params to optional CLI args.","title":"1.3.0 (July 21, 2019)"},{"location":"changelog/#125-june-30-2019","text":"Prepare for postponed annotation evaluation, which will be the default in Python 4.0 (see #2).","title":"1.2.5 (June 30, 2019)"},{"location":"changelog/#124-june-27-2019","text":"Add show_defaults param to set_help util. Read more .","title":"1.2.4 (June 27, 2019)"},{"location":"changelog/#123-may-13-2019","text":"Fix Python 3.7 incompatibility. Add set_sharg_map to override or disable short arg names.","title":"1.2.3 (May 13, 2019)"},{"location":"changelog/#122-june-3-2018","text":"Make _root not an abstract method.","title":"1.2.2 (June 3, 2018)"},{"location":"changelog/#121-june-2-2018","text":"Fix critical bug that disallowed string params.","title":"1.2.1 (June 2, 2018)"},{"location":"changelog/#120-june-1-2018","text":"Boolean handler params are converted into store_true arguments. Before that, params with default value of True were much confusingly converted into store_false arguments. Support List[int] and similar arg types. If the param type is a subclass of typing.Iterable and has a type specified in brackets, it's converted into multivalue arg of the type in the brackets. Do not print help whenever _root command is invoked. Convert the cliar module into a package. Add tests. Switch to Poetry.","title":"1.2.0 (June 1, 2018)"},{"location":"changelog/#119","text":"Add the ability to set help messages for arguments. Add the ability to set metavars for arguments.","title":"1.1.9"},{"location":"changelog/#118","text":"[Breaks backward compatibility] Base CLI class renamed from CLI to Cliar . Fixed a bug where commandline args with dashes weren't mapped to corresponding param names with underscores.","title":"1.1.8"},{"location":"changelog/#117","text":"Add the ability to override mapping between commandline args and and handler params. By default, handler params correspond to args of the same name with underscores replaced with dashes.","title":"1.1.7"},{"location":"changelog/#116","text":"Underscores in handler names are now replaced with dashes when the corresponding command name is generated.","title":"1.1.6"},{"location":"changelog/#115","text":"Optional arguments are now prepended with '--', not '-'. Short argument names are now generated from the long ones: name handler arg corresponds to -n and --name commandline args. Python 2 support dropped. Python 3.5+ required. Code refactored, type hints added.","title":"1.1.5"},{"location":"changelog/#114","text":"Code improvements for API documentation.","title":"1.1.4"},{"location":"changelog/#113","text":"Code cleanup.","title":"1.1.3"},{"location":"changelog/#112","text":"Setup: Python version check improved.","title":"1.1.2"},{"location":"changelog/#111","text":"Python 2: If only the _root handler was defined, a \"too few agruments\" error raised. Fixed. If only the _root handler is defined, the commands subparser is not added anymore. Packaging improved, the installation package now includes both Python 2 and 3 sources.","title":"1.1.1"},{"location":"changelog/#110","text":"Command descriptions did not preserve line breaks from docstrings. Fixed.","title":"1.1.0"},{"location":"changelog/#109","text":"Commands now use the first docstring line as help and the whole docstring as description.","title":"1.0.9"},{"location":"changelog/#108","text":"Description and help texts now preserve line breaks from docstrings.","title":"1.0.8"},{"location":"changelog/#107","text":"Support of multiple values for a single arg added.","title":"1.0.7"},{"location":"changelog/#106","text":"Command-line args are now parsed by explicitly calling the .parse() method.","title":"1.0.6"},{"location":"changelog/#105","text":"The ignore decorator added to exclude a method from being converted into a command.","title":"1.0.5"},{"location":"changelog/#104","text":"Nested CLI methods would not override parent methods. Fixed.","title":"1.0.4"},{"location":"changelog/#103","text":"Python 2 support added.","title":"1.0.3"},{"location":"changelog/#102","text":"Docstring added to the add_aliases function. The set_name function is now less hacky.","title":"1.0.2"},{"location":"changelog/#101","text":"Alias support added with the \"add_aliases\" decorator.","title":"1.0.1"},{"location":"changelog/#100","text":"First version. Changelog started.","title":"1.0.0"},{"location":"comparison/","text":"Cliar vs. Click vs. docopt \u00b6 It may seem strange to develop yet another Python package for CLI creation when we already have great tools like Click and docopt. Why not use one of those? It turns out there's at least one area where Click and docopt just won't do\u2014 modular CLI . Below, I'll try to explain what I mean by modular CLIs and why they are important. A will also cover other things that make Cliar special. Name Modular CLIs DSL-free Magic-free Type casting Pun in name Cliar \u2714 \u2714 \u2714 \u2714 \u2714 Click \u274c \u2714 \u274c \u2714 \u2714 docopt \u274c \u274c \u2714 \u274c \u274c Note Of course, any tool lets you do anything. When I say \"feature X is not supported by tool Y,\" I mean that the effort needed to implement X with Y is in my opinion too high. Conclusions are based on official docs of the tools being compared. Feel free to disagree. Modular CLIs \u00b6 Imagine you're developing a CLI-based audio player. You want it to have a ton of features but you don't want to develop them all on your own. The core version will only play a given file, but the rest of the functionality will be implemented with extensions. You want the usage of the player to be something like this: $ player play file.mp3 # Core functionality $ pip install player.ext.seek # Install extension $ player seek \"1:23\" # Extension-provided functionality This approach has several benefits: the user will be able to install only the parts they need you will be able to delegate responsibility to the community new commands are added via a unified API, which is the same for core and third-party developers So, your job is provide a way for third parties to add commands to the basic CLI and override existing commands. With docopt this is almost impossible since CLIs are declared in plaintext using a DSL: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' from docopt import docopt if __name__ == '__main__' : arguments = docopt ( __doc__ ) Adding a new command means adding a line into a spec before it gets parsed, so the only way an extension can add a new command to the base CLI is by inserting lines into the base CLI spec. This is inconvenient if you're adding one command, but it's a nightmare if you're creating an API for adding unlimited commands: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' from docopt import docopt from player.ext.seek import insert_seek_command # \"insert_seek_command\" function inserts \"player seek <pos>\" # after \"player play\". You can already feel how quickly it gets old. if __name__ == '__main__' : extended_doc = insert_seek_command ( __doc__ ) arguments = docopt ( extended_doc ) With Click , you can reuse commands from one CLI in another one: # In file a: cli = click . Group () @cli . command () def cmd_a (): print ( \"You called cmd_a\" ) # In file b: from a import cli @cli . command () def cmd_b (): print ( \"You called cmd_b\" ) Thanks to /u/Brian for the code sample . However, you can't reuse commands from multiple third-party modules in one CLI, which is what we want. That's because command reuse relations are defined with decorators, and you can't decorate an imported function. In other words, you can create a new player that implements seek and borrows play from player , but you can't add seek into player . With Cliar , extending an existing CLI is trivial. Since in Cliar a CLI is a regular Python class, extending it means extending the class the most natural way\u2014with inheritance. Just subclass your CLI from as many Cliar ancestors as you need: from cliar import Cliar # Basic CLI: class BasicCLI ( CLiar ): def play ( self , path ): ... # Seek extension: class SeekCLI ( Cliar ): def seek ( self , position ): ... # Complete CLI: class CLI ( BasicCLI , SeekCLI , * MoreExtensions ): '''The complete CLI that borrows from the basic CLI and extensionss. Notice that the class body is empty: the logic is already implemented by the parents. ''' pass Cliar relies on Python's standard mechanisms and doesn't reinvent the wheel when it comes to adding new features to objects. Python supports both single and multiple inheritance, so CLI extension goes both ways: you can create a completely new interface that borrows from an existing one or build an interface from extensions. DSL-Free \u00b6 DSLs should be avoided when pure Python is enough. A DSL requires time to learn, and the knowledge you gain is useless outside the scope of the DSL, which is by definition the app it's used in. Note This thought has been explained by Robert E Brewer in The Zen in CherryPy . In Docopt , you describe your CLI using a DSL. Then, you ask docopt to parse the commandline string and pass the extracted values to the business logic. The interface is completely separated from the business logic. It may seem a good idea until you actually start using docopt. What happens is you end up duplicating argument definitions all the time: '''Player. Usage: player play <file> player seek <position> player (-h | --help) Options: -h --help Show this screen. ''' # one time from docopt import docopt def play ( file ): # two times ... def seek ( position ): ... if __name__ == '__main__' : arguments = docopt ( __doc__ ) if arguments . get ( 'play' ): # three times play ( arguments [ '<file>' ]) elif arguments . get ( 'seek' ): seek ( arguments [ '<position>' ]) ... # ...and it goes on and on and on. Even in this toy example you can see how much redundant code this pattern spawns. Click and Cliar are DSL-free. Whereas docopt is \"spec first,\" Click and Cliar are \"code first\": they generate the usage text from the code, not the other way around. Magic-Free \u00b6 Magic is unusual behavior driven by a hidden mechanism. It may give a short \"wow\" effect, but the price to pay is that code becomes harder to debug and harder to follow. Writing idiomatic Python generally means avoiding magic. To see if a tool is \"magical,\" remove it from the code and see if the code breaks. Docopt , for example, is magic-free. If you remove the __doc__ parsing part, the remaining code is still 100% valid Python. Removing docopt does not break you program, it just removes the commandline parsing functionality: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' # from docopt import docopt if __name__ == '__main__' : # arguments = docopt(__doc__) pass Click , on the other hand, is full of magic. Let's examine the hello world example from the Click documentation : import click @click . command () @click . option ( '--count' , default = 1 , help = 'Number of greetings.' ) @click . option ( '--name' , prompt = 'Your name' , help = 'The person to greet.' ) def hello ( count , name ): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" for x in range ( count ): click . echo ( 'Hello %s !' % name ) if __name__ == '__main__' : hello () Note that hello function accepts two positional arguments, count and name , but we call it without any arguments. That's because the params are added by the decorators based on the arguments of the decorator generators ( --count and --name ). This is broken code only forced to work by the magic of Click's decorators. Cliar is magic-free. Your CLI classes are regular Python classes. If you remove Cliar from its parents, the class will remain functional. It will continue to contain all the business logic, only without the CLI: # from cliar import Cliar # class Player(Cliar): class Player ( object ): def play ( self , file ): print ( f 'Playing { file } ' ) Cliar's decorators like set_name or add_aliases can also be safely remove without breaking any code. Type Casting \u00b6 In commandline, any argument or flag value is a string. Converting strings to numbers and other types manually within business logic is tedious, requires dancing with exception handling, and, most importantly, has nothing to do with the business logic itself: it's a necessity induced by the fact the shell works only with strings and Python works with all sorts of types. Docopt doesn't attempt to cast types. It just parses a string into smaller ones in a nicely structured way, leaving all the necessary processing to the programmer: args = docopt ( __doc__ ) if args [ 'play' ]: file = Path ( args [ '<file>' ]) Click lets you define an argument and option type in the decorator constructor: @click . argument ( 'num' , type = int ) If the type is not set, Click tries to infer it from the default value. It that's not set as well, string is assumed. Cliar lets you define argument and option type with type hints. The logic is similar to Click's: if the type hint is given, use it, if not, infer the type from the default value, otherwise assume string: def play ( file : Path , num = 1 )","title":"Cliar vs. Click vs. docopt"},{"location":"comparison/#cliar-vs-click-vs-docopt","text":"It may seem strange to develop yet another Python package for CLI creation when we already have great tools like Click and docopt. Why not use one of those? It turns out there's at least one area where Click and docopt just won't do\u2014 modular CLI . Below, I'll try to explain what I mean by modular CLIs and why they are important. A will also cover other things that make Cliar special. Name Modular CLIs DSL-free Magic-free Type casting Pun in name Cliar \u2714 \u2714 \u2714 \u2714 \u2714 Click \u274c \u2714 \u274c \u2714 \u2714 docopt \u274c \u274c \u2714 \u274c \u274c Note Of course, any tool lets you do anything. When I say \"feature X is not supported by tool Y,\" I mean that the effort needed to implement X with Y is in my opinion too high. Conclusions are based on official docs of the tools being compared. Feel free to disagree.","title":"Cliar vs. Click vs. docopt"},{"location":"comparison/#modular-clis","text":"Imagine you're developing a CLI-based audio player. You want it to have a ton of features but you don't want to develop them all on your own. The core version will only play a given file, but the rest of the functionality will be implemented with extensions. You want the usage of the player to be something like this: $ player play file.mp3 # Core functionality $ pip install player.ext.seek # Install extension $ player seek \"1:23\" # Extension-provided functionality This approach has several benefits: the user will be able to install only the parts they need you will be able to delegate responsibility to the community new commands are added via a unified API, which is the same for core and third-party developers So, your job is provide a way for third parties to add commands to the basic CLI and override existing commands. With docopt this is almost impossible since CLIs are declared in plaintext using a DSL: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' from docopt import docopt if __name__ == '__main__' : arguments = docopt ( __doc__ ) Adding a new command means adding a line into a spec before it gets parsed, so the only way an extension can add a new command to the base CLI is by inserting lines into the base CLI spec. This is inconvenient if you're adding one command, but it's a nightmare if you're creating an API for adding unlimited commands: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' from docopt import docopt from player.ext.seek import insert_seek_command # \"insert_seek_command\" function inserts \"player seek <pos>\" # after \"player play\". You can already feel how quickly it gets old. if __name__ == '__main__' : extended_doc = insert_seek_command ( __doc__ ) arguments = docopt ( extended_doc ) With Click , you can reuse commands from one CLI in another one: # In file a: cli = click . Group () @cli . command () def cmd_a (): print ( \"You called cmd_a\" ) # In file b: from a import cli @cli . command () def cmd_b (): print ( \"You called cmd_b\" ) Thanks to /u/Brian for the code sample . However, you can't reuse commands from multiple third-party modules in one CLI, which is what we want. That's because command reuse relations are defined with decorators, and you can't decorate an imported function. In other words, you can create a new player that implements seek and borrows play from player , but you can't add seek into player . With Cliar , extending an existing CLI is trivial. Since in Cliar a CLI is a regular Python class, extending it means extending the class the most natural way\u2014with inheritance. Just subclass your CLI from as many Cliar ancestors as you need: from cliar import Cliar # Basic CLI: class BasicCLI ( CLiar ): def play ( self , path ): ... # Seek extension: class SeekCLI ( Cliar ): def seek ( self , position ): ... # Complete CLI: class CLI ( BasicCLI , SeekCLI , * MoreExtensions ): '''The complete CLI that borrows from the basic CLI and extensionss. Notice that the class body is empty: the logic is already implemented by the parents. ''' pass Cliar relies on Python's standard mechanisms and doesn't reinvent the wheel when it comes to adding new features to objects. Python supports both single and multiple inheritance, so CLI extension goes both ways: you can create a completely new interface that borrows from an existing one or build an interface from extensions.","title":"Modular CLIs"},{"location":"comparison/#dsl-free","text":"DSLs should be avoided when pure Python is enough. A DSL requires time to learn, and the knowledge you gain is useless outside the scope of the DSL, which is by definition the app it's used in. Note This thought has been explained by Robert E Brewer in The Zen in CherryPy . In Docopt , you describe your CLI using a DSL. Then, you ask docopt to parse the commandline string and pass the extracted values to the business logic. The interface is completely separated from the business logic. It may seem a good idea until you actually start using docopt. What happens is you end up duplicating argument definitions all the time: '''Player. Usage: player play <file> player seek <position> player (-h | --help) Options: -h --help Show this screen. ''' # one time from docopt import docopt def play ( file ): # two times ... def seek ( position ): ... if __name__ == '__main__' : arguments = docopt ( __doc__ ) if arguments . get ( 'play' ): # three times play ( arguments [ '<file>' ]) elif arguments . get ( 'seek' ): seek ( arguments [ '<position>' ]) ... # ...and it goes on and on and on. Even in this toy example you can see how much redundant code this pattern spawns. Click and Cliar are DSL-free. Whereas docopt is \"spec first,\" Click and Cliar are \"code first\": they generate the usage text from the code, not the other way around.","title":"DSL-Free"},{"location":"comparison/#magic-free","text":"Magic is unusual behavior driven by a hidden mechanism. It may give a short \"wow\" effect, but the price to pay is that code becomes harder to debug and harder to follow. Writing idiomatic Python generally means avoiding magic. To see if a tool is \"magical,\" remove it from the code and see if the code breaks. Docopt , for example, is magic-free. If you remove the __doc__ parsing part, the remaining code is still 100% valid Python. Removing docopt does not break you program, it just removes the commandline parsing functionality: '''Player. Usage: player play <file> player (-h | --help) Options: -h --help Show this screen. ''' # from docopt import docopt if __name__ == '__main__' : # arguments = docopt(__doc__) pass Click , on the other hand, is full of magic. Let's examine the hello world example from the Click documentation : import click @click . command () @click . option ( '--count' , default = 1 , help = 'Number of greetings.' ) @click . option ( '--name' , prompt = 'Your name' , help = 'The person to greet.' ) def hello ( count , name ): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" for x in range ( count ): click . echo ( 'Hello %s !' % name ) if __name__ == '__main__' : hello () Note that hello function accepts two positional arguments, count and name , but we call it without any arguments. That's because the params are added by the decorators based on the arguments of the decorator generators ( --count and --name ). This is broken code only forced to work by the magic of Click's decorators. Cliar is magic-free. Your CLI classes are regular Python classes. If you remove Cliar from its parents, the class will remain functional. It will continue to contain all the business logic, only without the CLI: # from cliar import Cliar # class Player(Cliar): class Player ( object ): def play ( self , file ): print ( f 'Playing { file } ' ) Cliar's decorators like set_name or add_aliases can also be safely remove without breaking any code.","title":"Magic-Free"},{"location":"comparison/#type-casting","text":"In commandline, any argument or flag value is a string. Converting strings to numbers and other types manually within business logic is tedious, requires dancing with exception handling, and, most importantly, has nothing to do with the business logic itself: it's a necessity induced by the fact the shell works only with strings and Python works with all sorts of types. Docopt doesn't attempt to cast types. It just parses a string into smaller ones in a nicely structured way, leaving all the necessary processing to the programmer: args = docopt ( __doc__ ) if args [ 'play' ]: file = Path ( args [ '<file>' ]) Click lets you define an argument and option type in the decorator constructor: @click . argument ( 'num' , type = int ) If the type is not set, Click tries to infer it from the default value. It that's not set as well, string is assumed. Cliar lets you define argument and option type with type hints. The logic is similar to Click's: if the type hint is given, use it, if not, infer the type from the default value, otherwise assume string: def play ( file : Path , num = 1 )","title":"Type Casting"},{"location":"tutorial/","text":"Tutorial \u00b6 This quick tutorial will guide you through all Cliar's features. We'll start with a simple \"Hello World\" example and progressively add features to it. Download the complete app: greeter.py Hello World \u00b6 Here's the simplest \"Hello World\" program with Cliar: from cliar import Cliar class Greeter ( Cliar ): def hello ( self ): print ( 'Hello World!' ) if __name__ == '__main__' : Greeter () . parse () In Cliar, CLI is a subclass of Cliar , with its methods turned into commands and their params into args. Save this code into greeter.py and run it: $ python greeter.py hello Hello World! Optional Flags \u00b6 Let's add a --shout flag to hello : def hello ( self , shout = False ): greeting = 'Hello World!' print ( greeting . upper () if shout else greeting ) Try running greeter.py with and without the newly defined flag: $ python greeter.py hello --shout HELLO WORLD! $ python greeter.py hello -s HELLO WORLD! $ python greeter.py hello Hello World! Positional Arguments \u00b6 Positional args are added the same way as flags. def hello ( self , name , shout = False ): greeting = f 'Hello { name } !' print ( greeting . upper () if shout else greeting ) Try it: $ python greeter.py hello John Hello John! $ python greeter.py hello John --shout HELLO JOHN! $ python greeter.py hello -s John HELLO JOHN! $ python greeter.py hello usage: greeter.py hello [ -h ] [ -s ] name greeter.py hello: error: the following arguments are required: name Help Messages \u00b6 Cliar automatically registers --help flag for the program itself and its every command: $ python greeter.py --help usage: greeter.py [ -h ] { hello } ... optional arguments: -h, --help show this help message and exit commands: { hello } Available commands: hello $ python greeter.py hello --help usage: greeter.py hello [ -h ] [ -s ] name positional arguments: name optional arguments: -h, --help show this help message and exit -s, --shout Command help messages are generated from docstrings. Let's add them: class Greeter ( Cliar ): '''Greeter app created with Cliar.''' def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' print ( greeting . upper () if shout else greeting ) and view the updated help message: $ python greeter.py -h usage: greeter.py [ -h ] { hello } ... Greeter app created with Cliar. optional arguments: -h, --help show this help message and exit commands: { hello } Available commands: hello Say hello. $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name optional arguments: -h, --help show this help message and exit -s, --shout To add description for arguments, use set_help decorator: from cliar import Cliar , set_help ... @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' print ( greeting . upper () if shout else greeting ) The decorator takes a mapping from param names to help messages. Call the help message for hello command: $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name Who to greet optional arguments: -h, --help show this help message and exit -s, --shout Shout the greeting To show default values for flags, add show_defaults = True to set_help : ... @set_help ( { 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }, show_defaults = True ) def hello ( self , name , shout = False ): ... Call help again to see the default value: $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name Who to greet optional arguments: -h, --help show this help message and exit -s, --shout Shout the greeting ( default: False ) Metavars \u00b6 Metavar is a placeholder of a positional arg as it appears in the help message. By default, Cliar uses the param name as its metavar. So, for name param the metavar is called name : $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name Who to greet optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting To set a different metavar for a param, usd set_metavars decorator: from cliar import Cliar , set_help , set_metavars ... @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' print ( greeting . upper () if shout else greeting ) The decorator takes a mapping from param names to metavars. Call the help message for hello : usage: greeter.py hello [ -h ] [ -s ] NAME Say hello. positional arguments: NAME Who to greet optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting Type Casting \u00b6 Cliar casts arg types of args on the fly. To use type casting, add type hints or default values to params. Let's add -n flag that will tell how many times to repeat the greeting: @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' for _ in range ( n ): print ( greeting . upper () if shout else greeting ) Let's call hello with the new flag: $ python greeter.py hello John -n 2 Hello John! Hello John! If we pass a non-integer value to -n , an error occurs: $ python greeter.py hello John -n foo usage: greeter.py hello [ -h ] [ -n N ] [ -s ] NAME greeter.py hello: error: argument -n/--n: invalid int value: 'foo' Hint You can use any callable as a param type, and it will be called to cast the param type during parsing. One useful example is using open as the param type: def read_from_file(input_file: open): lines = input_file.readlines() If you pass a path to such a param, Cliar will open it and pass the resulting file-like object to the handler body. And when the handler returns, Cliar will make sure the file gets closed. Argument Names \u00b6 By default, Cliar takes the param name, replaces underscores with dashes, and uses that as the corresponding arg name: name is turned into --name , and upper_limit into --upper-limit ; the first letter is used as a short option: -n for --name , -u for --upper-limit . To use different arg names, use set_arg_map decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map ... @set_arg_map ({ 'n' : 'repeat' }) @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' for _ in range ( n ): print ( greeting . upper () if shout else greeting ) Now use --repeat or -r instead of -n : $ python greeter.py hello John --repeat 2 Hello John! Hello John! $ python greeter.py hello John -r 2 Hello John! Hello John! Hint This decorator lets you use Python's reserved words like --for and --with as arg names. You can also override argument short names specifically, with set_sharg_map decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , set_sharg_map ... @set_arg_map ({ 'n' : 'repeat' }) @set_sharg_map ({ 'n' : 'n' }) @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' for _ in range ( n ): print ( greeting . upper () if shout else greeting ) Now you can use -n instead of -r : $ python greeter.py hello John --repeat 2 Hello John! Hello John! $ python greeter.py hello John -n 2 Hello John! Hello John! This is useful when you have several arguments that start with the same letter, which creates a conflict between short arg names. To disable short argument variant entirely, set the short arg name to None : @set_sharg_map({'argname': None}) . Multiple Commands \u00b6 Adding more commands to the CLI simply means adding more methods to the CLI class: class Greeter ( Cliar ): def goodbye ( self , name ): '''Say goodbye''' print ( f 'Goodbye { name } !' ) @set_arg_map ({ 'n' : 'repeat' }) ... With this code addition, you can call goodbye command: $ python greeter.py goodbye Mary Goodbye Mary! Nested Commands \u00b6 You can have any level of nested commands by adding Cliar CLIs as class attributes. For example, let's add a utils subcommand with its own time subcommand that has now command: class Time ( Cliar ): def now ( self , utc = False ): now_ctime = datetime . utcnow () . ctime () if utc else datetime . now () . ctime () print ( f 'UTC time is { now_ctime } ' ) class Utils ( Cliar ): time = Time class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' utils = Utils def _root ( self , version = False ): ... You can now call now command through utils : $ python greeter.py utils time now Local time is Sun Jul 21 15 :25:52 2019 $ python greeter.py utils time now --utc UTC time is Sun Jul 21 11 :25:57 2019 Command Aliases \u00b6 To add aliases to a command, use add_aliases decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases ... @add_aliases ([ 'mientras' , '\u043f\u043e\u043a\u0430' ]) def goodbye ( self , name ): '''Say goodbye''' print ( f 'Goodbye { name } !' ) Now you can call goodbye command by its aliases: $ python greeter.py mientras Maria Goodbye Maria! $ python greeter.py \u043f\u043e\u043a\u0430 \u041c\u0430\u0448\u0430 Goodbye \u041c\u0430\u0448\u0430! Command Names \u00b6 By default, CLI commands are named after the corresponding methods. To override this behavior and set a custom command name, use set_name decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases , set_name class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' @set_name ( 'factorial' ) # Name the command `factorial` def calculate_factorial ( self , n : int ): # because `calculate_factorial` '''Calculate factorial''' # is too long for CLI. print ( f 'n! = { factorial ( n ) } ' ) Now calculate_factorial is called with factorial command: $ python greeter.py factorial 4 n! = 24 $ python greeter.py calculate_factorial 4 usage: greeter.py [ -h ] { factorial,goodbye,mientras,\u043f\u043e\u043a\u0430,hello } ... greeter.py: error: argument command: invalid choice: 'calculate_factorial' ( choose from 'factorial' , 'goodbye' , 'mientras' , '\u043f\u043e\u043a\u0430' , 'hello' ) Ignore Methods \u00b6 By default, Cliar converts all non-static and non-class methods of the Cliar subclass into CLI commands. There are two ways to tell Cliar not to convert a method into a command: start its name with an underscore or use ignore decorator: from math import factorial , tau , pi from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases , set_name , ignore class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def _get_tau_value ( self ): return tau @ignore def get_pi_value ( self ): return pi def constants ( self ): print ( f '\u03c4 = { self . _get_tau_value () } ' ) print ( f '\u03c0 = { self . get_pi_value () } ' ) ... Only constants method will be exposed as a CLI command: $ python greeter.py constants \u03c4 = 6 .283185307179586 \u03c0 = 3 .141592653589793 $ python greeter.py get-pi-value usage: greeter.py [ -h ] { factorial,constants,goodbye,mientras,\u043f\u043e\u043a\u0430,hello } ... greeter.py: error: argument command: invalid choice: 'get-pi-value' ( choose from 'factorial' , 'constants' , 'goodbye' , 'mientras' , '\u043f\u043e\u043a\u0430' , 'hello' ) Root Command \u00b6 To assign action to the root command, i.e. the script itself, define _root method: class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def _root ( self , version = False ): print ( 'Greeter 1.0.0.' if version else 'Welcome to Greeter!' ) ... If you run greeter.py with --version or -v flag, you'll see its version. If you call greeter.py without any flags or commands, you'll see a welcome message: $ python greeter.py Welcome to Greeter! $ python greeter.py --version Greeter 1 .0.0. Global Arguments \u00b6 Global arguments defined in _root can be accessed in commands via self.global_args : ... def constants ( self ): if self . global_args . get ( 'version' ): print ( 'Greeter 1.0.0.' ) print ( f '\u03c4 = { self . _get_tau_value () } ' ) print ( f '\u03c0 = { self . get_pi_value () } ' ) ... Run constants with --version : $ python greeter.py --version constants Greeter 1 .0.0. \u03c4 = 6 .283185307179586 \u03c0 = 3 .141592653589793 This works with nested commands , too. Global arguments of nested commands override global arguments of their parents.","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This quick tutorial will guide you through all Cliar's features. We'll start with a simple \"Hello World\" example and progressively add features to it. Download the complete app: greeter.py","title":"Tutorial"},{"location":"tutorial/#hello-world","text":"Here's the simplest \"Hello World\" program with Cliar: from cliar import Cliar class Greeter ( Cliar ): def hello ( self ): print ( 'Hello World!' ) if __name__ == '__main__' : Greeter () . parse () In Cliar, CLI is a subclass of Cliar , with its methods turned into commands and their params into args. Save this code into greeter.py and run it: $ python greeter.py hello Hello World!","title":"Hello World"},{"location":"tutorial/#optional-flags","text":"Let's add a --shout flag to hello : def hello ( self , shout = False ): greeting = 'Hello World!' print ( greeting . upper () if shout else greeting ) Try running greeter.py with and without the newly defined flag: $ python greeter.py hello --shout HELLO WORLD! $ python greeter.py hello -s HELLO WORLD! $ python greeter.py hello Hello World!","title":"Optional Flags"},{"location":"tutorial/#positional-arguments","text":"Positional args are added the same way as flags. def hello ( self , name , shout = False ): greeting = f 'Hello { name } !' print ( greeting . upper () if shout else greeting ) Try it: $ python greeter.py hello John Hello John! $ python greeter.py hello John --shout HELLO JOHN! $ python greeter.py hello -s John HELLO JOHN! $ python greeter.py hello usage: greeter.py hello [ -h ] [ -s ] name greeter.py hello: error: the following arguments are required: name","title":"Positional Arguments"},{"location":"tutorial/#help-messages","text":"Cliar automatically registers --help flag for the program itself and its every command: $ python greeter.py --help usage: greeter.py [ -h ] { hello } ... optional arguments: -h, --help show this help message and exit commands: { hello } Available commands: hello $ python greeter.py hello --help usage: greeter.py hello [ -h ] [ -s ] name positional arguments: name optional arguments: -h, --help show this help message and exit -s, --shout Command help messages are generated from docstrings. Let's add them: class Greeter ( Cliar ): '''Greeter app created with Cliar.''' def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' print ( greeting . upper () if shout else greeting ) and view the updated help message: $ python greeter.py -h usage: greeter.py [ -h ] { hello } ... Greeter app created with Cliar. optional arguments: -h, --help show this help message and exit commands: { hello } Available commands: hello Say hello. $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name optional arguments: -h, --help show this help message and exit -s, --shout To add description for arguments, use set_help decorator: from cliar import Cliar , set_help ... @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' print ( greeting . upper () if shout else greeting ) The decorator takes a mapping from param names to help messages. Call the help message for hello command: $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name Who to greet optional arguments: -h, --help show this help message and exit -s, --shout Shout the greeting To show default values for flags, add show_defaults = True to set_help : ... @set_help ( { 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }, show_defaults = True ) def hello ( self , name , shout = False ): ... Call help again to see the default value: $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name Who to greet optional arguments: -h, --help show this help message and exit -s, --shout Shout the greeting ( default: False )","title":"Help Messages"},{"location":"tutorial/#metavars","text":"Metavar is a placeholder of a positional arg as it appears in the help message. By default, Cliar uses the param name as its metavar. So, for name param the metavar is called name : $ python greeter.py hello -h usage: greeter.py hello [ -h ] [ -s ] name Say hello. positional arguments: name Who to greet optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting To set a different metavar for a param, usd set_metavars decorator: from cliar import Cliar , set_help , set_metavars ... @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' print ( greeting . upper () if shout else greeting ) The decorator takes a mapping from param names to metavars. Call the help message for hello : usage: greeter.py hello [ -h ] [ -s ] NAME Say hello. positional arguments: NAME Who to greet optional arguments: -h, --help show this help message and exit -s, --shout Set to shout the greeting","title":"Metavars"},{"location":"tutorial/#type-casting","text":"Cliar casts arg types of args on the fly. To use type casting, add type hints or default values to params. Let's add -n flag that will tell how many times to repeat the greeting: @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' for _ in range ( n ): print ( greeting . upper () if shout else greeting ) Let's call hello with the new flag: $ python greeter.py hello John -n 2 Hello John! Hello John! If we pass a non-integer value to -n , an error occurs: $ python greeter.py hello John -n foo usage: greeter.py hello [ -h ] [ -n N ] [ -s ] NAME greeter.py hello: error: argument -n/--n: invalid int value: 'foo' Hint You can use any callable as a param type, and it will be called to cast the param type during parsing. One useful example is using open as the param type: def read_from_file(input_file: open): lines = input_file.readlines() If you pass a path to such a param, Cliar will open it and pass the resulting file-like object to the handler body. And when the handler returns, Cliar will make sure the file gets closed.","title":"Type Casting"},{"location":"tutorial/#argument-names","text":"By default, Cliar takes the param name, replaces underscores with dashes, and uses that as the corresponding arg name: name is turned into --name , and upper_limit into --upper-limit ; the first letter is used as a short option: -n for --name , -u for --upper-limit . To use different arg names, use set_arg_map decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map ... @set_arg_map ({ 'n' : 'repeat' }) @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' for _ in range ( n ): print ( greeting . upper () if shout else greeting ) Now use --repeat or -r instead of -n : $ python greeter.py hello John --repeat 2 Hello John! Hello John! $ python greeter.py hello John -r 2 Hello John! Hello John! Hint This decorator lets you use Python's reserved words like --for and --with as arg names. You can also override argument short names specifically, with set_sharg_map decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , set_sharg_map ... @set_arg_map ({ 'n' : 'repeat' }) @set_sharg_map ({ 'n' : 'n' }) @set_metavars ({ 'name' : 'NAME' }) @set_help ({ 'name' : 'Who to greet' , 'shout' : 'Shout the greeting' }) def hello ( self , name , n = 1 , shout = False ): '''Say hello.''' greeting = f 'Hello { name } !' for _ in range ( n ): print ( greeting . upper () if shout else greeting ) Now you can use -n instead of -r : $ python greeter.py hello John --repeat 2 Hello John! Hello John! $ python greeter.py hello John -n 2 Hello John! Hello John! This is useful when you have several arguments that start with the same letter, which creates a conflict between short arg names. To disable short argument variant entirely, set the short arg name to None : @set_sharg_map({'argname': None}) .","title":"Argument Names"},{"location":"tutorial/#multiple-commands","text":"Adding more commands to the CLI simply means adding more methods to the CLI class: class Greeter ( Cliar ): def goodbye ( self , name ): '''Say goodbye''' print ( f 'Goodbye { name } !' ) @set_arg_map ({ 'n' : 'repeat' }) ... With this code addition, you can call goodbye command: $ python greeter.py goodbye Mary Goodbye Mary!","title":"Multiple Commands"},{"location":"tutorial/#nested-commands","text":"You can have any level of nested commands by adding Cliar CLIs as class attributes. For example, let's add a utils subcommand with its own time subcommand that has now command: class Time ( Cliar ): def now ( self , utc = False ): now_ctime = datetime . utcnow () . ctime () if utc else datetime . now () . ctime () print ( f 'UTC time is { now_ctime } ' ) class Utils ( Cliar ): time = Time class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' utils = Utils def _root ( self , version = False ): ... You can now call now command through utils : $ python greeter.py utils time now Local time is Sun Jul 21 15 :25:52 2019 $ python greeter.py utils time now --utc UTC time is Sun Jul 21 11 :25:57 2019","title":"Nested Commands"},{"location":"tutorial/#command-aliases","text":"To add aliases to a command, use add_aliases decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases ... @add_aliases ([ 'mientras' , '\u043f\u043e\u043a\u0430' ]) def goodbye ( self , name ): '''Say goodbye''' print ( f 'Goodbye { name } !' ) Now you can call goodbye command by its aliases: $ python greeter.py mientras Maria Goodbye Maria! $ python greeter.py \u043f\u043e\u043a\u0430 \u041c\u0430\u0448\u0430 Goodbye \u041c\u0430\u0448\u0430!","title":"Command Aliases"},{"location":"tutorial/#command-names","text":"By default, CLI commands are named after the corresponding methods. To override this behavior and set a custom command name, use set_name decorator: from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases , set_name class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' @set_name ( 'factorial' ) # Name the command `factorial` def calculate_factorial ( self , n : int ): # because `calculate_factorial` '''Calculate factorial''' # is too long for CLI. print ( f 'n! = { factorial ( n ) } ' ) Now calculate_factorial is called with factorial command: $ python greeter.py factorial 4 n! = 24 $ python greeter.py calculate_factorial 4 usage: greeter.py [ -h ] { factorial,goodbye,mientras,\u043f\u043e\u043a\u0430,hello } ... greeter.py: error: argument command: invalid choice: 'calculate_factorial' ( choose from 'factorial' , 'goodbye' , 'mientras' , '\u043f\u043e\u043a\u0430' , 'hello' )","title":"Command Names"},{"location":"tutorial/#ignore-methods","text":"By default, Cliar converts all non-static and non-class methods of the Cliar subclass into CLI commands. There are two ways to tell Cliar not to convert a method into a command: start its name with an underscore or use ignore decorator: from math import factorial , tau , pi from cliar import Cliar , set_help , set_metavars , set_arg_map , add_aliases , set_name , ignore class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def _get_tau_value ( self ): return tau @ignore def get_pi_value ( self ): return pi def constants ( self ): print ( f '\u03c4 = { self . _get_tau_value () } ' ) print ( f '\u03c0 = { self . get_pi_value () } ' ) ... Only constants method will be exposed as a CLI command: $ python greeter.py constants \u03c4 = 6 .283185307179586 \u03c0 = 3 .141592653589793 $ python greeter.py get-pi-value usage: greeter.py [ -h ] { factorial,constants,goodbye,mientras,\u043f\u043e\u043a\u0430,hello } ... greeter.py: error: argument command: invalid choice: 'get-pi-value' ( choose from 'factorial' , 'constants' , 'goodbye' , 'mientras' , '\u043f\u043e\u043a\u0430' , 'hello' )","title":"Ignore Methods"},{"location":"tutorial/#root-command","text":"To assign action to the root command, i.e. the script itself, define _root method: class Greeter ( Cliar ): '''Greeter app created with in Cliar.''' def _root ( self , version = False ): print ( 'Greeter 1.0.0.' if version else 'Welcome to Greeter!' ) ... If you run greeter.py with --version or -v flag, you'll see its version. If you call greeter.py without any flags or commands, you'll see a welcome message: $ python greeter.py Welcome to Greeter! $ python greeter.py --version Greeter 1 .0.0.","title":"Root Command"},{"location":"tutorial/#global-arguments","text":"Global arguments defined in _root can be accessed in commands via self.global_args : ... def constants ( self ): if self . global_args . get ( 'version' ): print ( 'Greeter 1.0.0.' ) print ( f '\u03c4 = { self . _get_tau_value () } ' ) print ( f '\u03c0 = { self . get_pi_value () } ' ) ... Run constants with --version : $ python greeter.py --version constants Greeter 1 .0.0. \u03c4 = 6 .283185307179586 \u03c0 = 3 .141592653589793 This works with nested commands , too. Global arguments of nested commands override global arguments of their parents.","title":"Global Arguments"}]}